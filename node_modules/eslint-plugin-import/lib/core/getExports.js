'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.recursivePatternCapture = recursivePatternCapture;

require('es6-symbol/implement');

var _es6Map = require('es6-map');

var _es6Map2 = _interopRequireDefault(_es6Map);

var _fs = require('fs');

var fs = _interopRequireWildcard(_fs);

var _crypto = require('crypto');

var _doctrine = require('doctrine');

var doctrine = _interopRequireWildcard(_doctrine);

var _parse2 = require('./parse');

var _parse3 = _interopRequireDefault(_parse2);

var _resolve = require('./resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _ignore = require('./ignore');

var _ignore2 = _interopRequireDefault(_ignore);

var _hash = require('./hash');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var exportCache = new _es6Map2.default();

/**
 * detect exports without a full parse.
 * used primarily to ignore the import/ignore setting, iif it looks like
 * there might be something there (i.e., jsnext:main is set).
 * @type {RegExp}
 */
var hasExports = new RegExp('(^|[\\n;])\\s*export\\s[\\w{*]');

var ExportMap = function () {
  function ExportMap(path) {
    _classCallCheck(this, ExportMap);

    this.path = path;
    this.namespace = new _es6Map2.default();
    // todo: restructure to key on path, value is resolver + map of names
    this.reexports = new _es6Map2.default();
    this.dependencies = new _es6Map2.default();
    this.errors = [];
  }

  ExportMap.get = function get(source, context) {

    var path = (0, _resolve2.default)(source, context);
    if (path == null) return null;

    return ExportMap.for(path, context);
  };

  ExportMap.for = function _for(path, context) {
    var exportMap = void 0;

    var cacheKey = (0, _hash.hashObject)((0, _crypto.createHash)('sha256'), {
      settings: context.settings,
      parserPath: context.parserPath,
      parserOptions: context.parserOptions,
      path: path
    }).digest('hex');

    exportMap = exportCache.get(cacheKey);

    // return cached ignore
    if (exportMap === null) return null;

    var stats = fs.statSync(path);
    if (exportMap != null) {
      // date equality check
      if (exportMap.mtime - stats.mtime === 0) {
        return exportMap;
      }
      // future: check content equality?
    }

    var content = fs.readFileSync(path, { encoding: 'utf8' });

    // check for and cache ignore
    if ((0, _ignore2.default)(path, context) && !hasExports.test(content)) {
      exportCache.set(cacheKey, null);
      return null;
    }

    exportMap = ExportMap.parse(path, content, context);
    exportMap.mtime = stats.mtime;

    exportCache.set(cacheKey, exportMap);
    return exportMap;
  };

  ExportMap.parse = function parse(path, content, context) {
    var m = new ExportMap(path);

    try {
      var ast = (0, _parse3.default)(content, context);
    } catch (err) {
      m.errors.push(err);
      return m; // can't continue
    }

    // attempt to collect module doc
    ast.comments.some(function (c) {
      if (c.type !== 'Block') return false;
      try {
        var doc = doctrine.parse(c.value, { unwrap: true });
        if (doc.tags.some(function (t) {
          return t.title === 'module';
        })) {
          m.doc = doc;
          return true;
        }
      } catch (err) {/* ignore */}
      return false;
    });

    var namespaces = new _es6Map2.default();

    function remotePath(node) {
      return _resolve2.default.relative(node.source.value, path, context.settings);
    }

    function resolveImport(node) {
      var rp = remotePath(node);
      if (rp == null) return null;
      return ExportMap.for(rp, context);
    }

    function getNamespace(identifier) {
      if (!namespaces.has(identifier.name)) return;

      return function () {
        return resolveImport(namespaces.get(identifier.name));
      };
    }

    function addNamespace(object, identifier) {
      var nsfn = getNamespace(identifier);
      if (nsfn) {
        Object.defineProperty(object, 'namespace', { get: nsfn });
      }

      return object;
    }

    ast.body.forEach(function (n) {

      if (n.type === 'ExportDefaultDeclaration') {
        var exportMeta = captureDoc(n);
        if (n.declaration.type === 'Identifier') {
          addNamespace(exportMeta, n.declaration);
        }
        m.namespace.set('default', exportMeta);
        return;
      }

      if (n.type === 'ExportAllDeclaration') {
        var _ret = function () {
          var remoteMap = remotePath(n);
          if (remoteMap == null) return {
              v: void 0
            };
          m.dependencies.set(remoteMap, function () {
            return ExportMap.for(remoteMap, context);
          });
          return {
            v: void 0
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }

      // capture namespaces in case of later export
      if (n.type === 'ImportDeclaration') {
        var ns = void 0;
        if (n.specifiers.some(function (s) {
          return s.type === 'ImportNamespaceSpecifier' && (ns = s);
        })) {
          namespaces.set(ns.local.name, n);
        }
        return;
      }

      if (n.type === 'ExportNamedDeclaration') {
        // capture declaration
        if (n.declaration != null) {
          switch (n.declaration.type) {
            case 'FunctionDeclaration':
            case 'ClassDeclaration':
            case 'TypeAlias':
              // flowtype with babel-eslint parser
              m.namespace.set(n.declaration.id.name, captureDoc(n));
              break;
            case 'VariableDeclaration':
              n.declaration.declarations.forEach(function (d) {
                return recursivePatternCapture(d.id, function (id) {
                  return m.namespace.set(id.name, captureDoc(d, n));
                });
              });
              break;
          }
        }

        n.specifiers.forEach(function (s) {
          var exportMeta = {};
          var local = void 0;

          switch (s.type) {
            case 'ExportDefaultSpecifier':
              if (!n.source) return;
              local = 'default';
              break;
            case 'ExportNamespaceSpecifier':
              m.namespace.set(s.exported.name, Object.defineProperty(exportMeta, 'namespace', {
                get: function get() {
                  return resolveImport(n);
                }
              }));
              return;
            case 'ExportSpecifier':
              if (!n.source) {
                m.namespace.set(s.exported.name, addNamespace(exportMeta, s.local));
                return;
              }
            // else falls through
            default:
              local = s.local.name;
              break;
          }

          // todo: JSDoc
          m.reexports.set(s.exported.name, { local: local, getImport: function getImport() {
              return resolveImport(n);
            } });
        });
      }
    });

    return m;
  };

  /**
   * Note that this does not check explicitly re-exported names for existence
   * in the base namespace, but it will expand all `export * from '...'` exports
   * if not found in the explicit namespace.
   * @param  {string}  name
   * @return {Boolean} true if `name` is exported by this module.
   */


  ExportMap.prototype.has = function has(name) {
    if (this.namespace.has(name)) return true;
    if (this.reexports.has(name)) return true;

    for (var _iterator = this.dependencies.values(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var dep = _ref;

      var innerMap = dep();

      // todo: report as unresolved?
      if (!innerMap) continue;

      if (innerMap.has(name)) return true;
    }

    return false;
  };

  ExportMap.prototype.get = function get(name) {
    if (this.namespace.has(name)) return this.namespace.get(name);

    if (this.reexports.has(name)) {
      var _reexports$get = this.reexports.get(name);

      var local = _reexports$get.local;
      var getImport = _reexports$get.getImport;
      var imported = getImport();
      if (imported == null) return undefined;

      // safeguard against cycles, only if name matches
      if (imported.path === this.path && local === name) return undefined;

      return imported.get(local);
    }

    for (var _iterator2 = this.dependencies.values(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var dep = _ref2;

      var innerMap = dep();
      // todo: report as unresolved?
      if (!innerMap) continue;

      // safeguard against cycles
      if (innerMap.path === this.path) continue;

      var innerValue = innerMap.get(name);
      if (innerValue !== undefined) return innerValue;
    }

    return undefined;
  };

  ExportMap.prototype.forEach = function forEach(callback, thisArg) {
    var _this = this;

    this.namespace.forEach(function (v, n) {
      return callback.call(thisArg, v, n, _this);
    });

    this.reexports.forEach(function (_ref3, name) {
      var getImport = _ref3.getImport;
      var local = _ref3.local;
      return callback.call(thisArg, getImport().get(local), name, _this);
    });

    this.dependencies.forEach(function (dep) {
      return dep().forEach(function (v, n) {
        return callback.call(thisArg, v, n, _this);
      });
    });
  };

  // todo: keys, values, entries?

  ExportMap.prototype.reportErrors = function reportErrors(context, declaration) {
    context.report({
      node: declaration.source,
      message: 'Parse errors in imported module \'' + declaration.source.value + '\': ' + ('' + this.errors.map(function (e) {
        return e.message + ' (' + e.lineNumber + ':' + e.column + ')';
      }).join(', '))
    });
  };

  _createClass(ExportMap, [{
    key: 'hasDefault',
    get: function get() {
      return this.get('default') != null;
    } // stronger than this.has

  }, {
    key: 'size',
    get: function get() {
      var size = this.namespace.size + this.reexports.size;
      this.dependencies.forEach(function (dep) {
        return size += dep().size;
      });
      return size;
    }
  }]);

  return ExportMap;
}();

/**
 * parse JSDoc from the first node that has leading comments
 * @param  {...[type]} nodes [description]
 * @return {{doc: object}}
 */


exports.default = ExportMap;
function captureDoc() {
  var metadata = {};

  // 'some' short-circuits on first 'true'

  for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
    nodes[_key] = arguments[_key];
  }

  nodes.some(function (n) {
    if (!n.leadingComments) return false;

    // capture XSDoc
    n.leadingComments.forEach(function (comment) {
      // skip non-block comments
      if (comment.value.slice(0, 4) !== "*\n *") return;
      try {
        metadata.doc = doctrine.parse(comment.value, { unwrap: true });
      } catch (err) {
        /* don't care, for now? maybe add to `errors?` */
      }
    });
    return true;
  });

  return metadata;
}

/**
 * Traverse a pattern/identifier node, calling 'callback'
 * for each leaf identifier.
 * @param  {node}   pattern
 * @param  {Function} callback
 * @return {void}
 */
function recursivePatternCapture(pattern, callback) {
  switch (pattern.type) {
    case 'Identifier':
      // base case
      callback(pattern);
      break;

    case 'ObjectPattern':
      pattern.properties.forEach(function (_ref4) {
        var value = _ref4.value;

        recursivePatternCapture(value, callback);
      });
      break;

    case 'ArrayPattern':
      pattern.elements.forEach(function (element) {
        if (element == null) return;
        recursivePatternCapture(element, callback);
      });
      break;
  }
}
//# sourceMappingURL=data:application/json;base64,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LEtBQVIsQ0FBYyxLQUFkLENBQW9CLENBQXBCLEVBQXVCLENBQXZCLE1BQThCLE9BQTlCLEVBQXVDLE9BQTNDO0FBQ0EsVUFBSTtBQUNGLGlCQUFTLEdBQVQsR0FBZSxTQUFTLEtBQVQsQ0FBZSxRQUFRLEtBQVIsRUFBZSxFQUFFLFFBQVEsSUFBUixFQUFoQyxDQUFmLENBREU7T0FBSixDQUVFLE9BQU8sR0FBUCxFQUFZOztPQUFaO0tBTHNCLENBQTFCLENBSmM7QUFhZCxXQUFPLElBQVAsQ0FiYztHQUFMLENBQVgsQ0FKNEI7O0FBb0I1QixTQUFPLFFBQVAsQ0FwQjRCO0NBQTlCOzs7Ozs7Ozs7QUE4Qk8sU0FBUyx1QkFBVCxDQUFpQyxPQUFqQyxFQUEwQyxRQUExQyxFQUFvRDtBQUN6RCxVQUFRLFFBQVEsSUFBUjtBQUNOLFNBQUssWUFBTDs7QUFDRSxlQUFTLE9BQVQsRUFERjtBQUVFLFlBRkY7O0FBREYsU0FLTyxlQUFMO0FBQ0UsY0FBUSxVQUFSLENBQW1CLE9BQW5CLENBQTJCLGlCQUFlO1lBQVosb0JBQVk7O0FBQ3hDLGdDQUF3QixLQUF4QixFQUErQixRQUEvQixFQUR3QztPQUFmLENBQTNCLENBREY7QUFJRSxZQUpGOztBQUxGLFNBV08sY0FBTDtBQUNFLGNBQVEsUUFBUixDQUFpQixPQUFqQixDQUF5QixVQUFDLE9BQUQsRUFBYTtBQUNwQyxZQUFJLFdBQVcsSUFBWCxFQUFpQixPQUFyQjtBQUNBLGdDQUF3QixPQUF4QixFQUFpQyxRQUFqQyxFQUZvQztPQUFiLENBQXpCLENBREY7QUFLRSxZQUxGO0FBWEYsR0FEeUQ7Q0FBcEQiLCJmaWxlIjoiY29yZS9nZXRFeHBvcnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdlczYtc3ltYm9sL2ltcGxlbWVudCdcbmltcG9ydCBNYXAgZnJvbSAnZXM2LW1hcCdcblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnXG5cbmltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nXG5pbXBvcnQgKiBhcyBkb2N0cmluZSBmcm9tICdkb2N0cmluZSdcblxuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UnXG5pbXBvcnQgcmVzb2x2ZSBmcm9tICcuL3Jlc29sdmUnXG5pbXBvcnQgaXNJZ25vcmVkIGZyb20gJy4vaWdub3JlJ1xuXG5pbXBvcnQgeyBoYXNoT2JqZWN0IH0gZnJvbSAnLi9oYXNoJ1xuXG5jb25zdCBleHBvcnRDYWNoZSA9IG5ldyBNYXAoKVxuXG4vKipcbiAqIGRldGVjdCBleHBvcnRzIHdpdGhvdXQgYSBmdWxsIHBhcnNlLlxuICogdXNlZCBwcmltYXJpbHkgdG8gaWdub3JlIHRoZSBpbXBvcnQvaWdub3JlIHNldHRpbmcsIGlpZiBpdCBsb29rcyBsaWtlXG4gKiB0aGVyZSBtaWdodCBiZSBzb21ldGhpbmcgdGhlcmUgKGkuZS4sIGpzbmV4dDptYWluIGlzIHNldCkuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCBoYXNFeHBvcnRzID0gbmV3IFJlZ0V4cCgnKF58W1xcXFxuO10pXFxcXHMqZXhwb3J0XFxcXHNbXFxcXHd7Kl0nKVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHBvcnRNYXAge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aFxuICAgIHRoaXMubmFtZXNwYWNlID0gbmV3IE1hcCgpXG4gICAgLy8gdG9kbzogcmVzdHJ1Y3R1cmUgdG8ga2V5IG9uIHBhdGgsIHZhbHVlIGlzIHJlc29sdmVyICsgbWFwIG9mIG5hbWVzXG4gICAgdGhpcy5yZWV4cG9ydHMgPSBuZXcgTWFwKClcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuZXJyb3JzID0gW11cbiAgfVxuXG4gIGdldCBoYXNEZWZhdWx0KCkgeyByZXR1cm4gdGhpcy5nZXQoJ2RlZmF1bHQnKSAhPSBudWxsIH0gLy8gc3Ryb25nZXIgdGhhbiB0aGlzLmhhc1xuXG4gIGdldCBzaXplKCkge1xuICAgIGxldCBzaXplID0gdGhpcy5uYW1lc3BhY2Uuc2l6ZSArIHRoaXMucmVleHBvcnRzLnNpemVcbiAgICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGRlcCA9PiBzaXplICs9IGRlcCgpLnNpemUpXG4gICAgcmV0dXJuIHNpemVcbiAgfVxuXG4gIHN0YXRpYyBnZXQoc291cmNlLCBjb250ZXh0KSB7XG5cbiAgICB2YXIgcGF0aCA9IHJlc29sdmUoc291cmNlLCBjb250ZXh0KVxuICAgIGlmIChwYXRoID09IG51bGwpIHJldHVybiBudWxsXG5cbiAgICByZXR1cm4gRXhwb3J0TWFwLmZvcihwYXRoLCBjb250ZXh0KVxuICB9XG5cbiAgc3RhdGljIGZvcihwYXRoLCBjb250ZXh0KSB7XG4gICAgbGV0IGV4cG9ydE1hcFxuXG4gICAgY29uc3QgY2FjaGVLZXkgPSBoYXNoT2JqZWN0KGNyZWF0ZUhhc2goJ3NoYTI1NicpLCB7XG4gICAgICBzZXR0aW5nczogY29udGV4dC5zZXR0aW5ncyxcbiAgICAgIHBhcnNlclBhdGg6IGNvbnRleHQucGFyc2VyUGF0aCxcbiAgICAgIHBhcnNlck9wdGlvbnM6IGNvbnRleHQucGFyc2VyT3B0aW9ucyxcbiAgICAgIHBhdGgsXG4gICAgfSkuZGlnZXN0KCdoZXgnKVxuXG4gICAgZXhwb3J0TWFwID0gZXhwb3J0Q2FjaGUuZ2V0KGNhY2hlS2V5KVxuXG4gICAgLy8gcmV0dXJuIGNhY2hlZCBpZ25vcmVcbiAgICBpZiAoZXhwb3J0TWFwID09PSBudWxsKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhwYXRoKVxuICAgIGlmIChleHBvcnRNYXAgIT0gbnVsbCkge1xuICAgICAgLy8gZGF0ZSBlcXVhbGl0eSBjaGVja1xuICAgICAgaWYgKGV4cG9ydE1hcC5tdGltZSAtIHN0YXRzLm10aW1lID09PSAwKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRNYXBcbiAgICAgIH1cbiAgICAgIC8vIGZ1dHVyZTogY2hlY2sgY29udGVudCBlcXVhbGl0eT9cbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHBhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KVxuXG4gICAgLy8gY2hlY2sgZm9yIGFuZCBjYWNoZSBpZ25vcmVcbiAgICBpZiAoaXNJZ25vcmVkKHBhdGgsIGNvbnRleHQpICYmICFoYXNFeHBvcnRzLnRlc3QoY29udGVudCkpIHtcbiAgICAgIGV4cG9ydENhY2hlLnNldChjYWNoZUtleSwgbnVsbClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZXhwb3J0TWFwID0gRXhwb3J0TWFwLnBhcnNlKHBhdGgsIGNvbnRlbnQsIGNvbnRleHQpXG4gICAgZXhwb3J0TWFwLm10aW1lID0gc3RhdHMubXRpbWVcblxuICAgIGV4cG9ydENhY2hlLnNldChjYWNoZUtleSwgZXhwb3J0TWFwKVxuICAgIHJldHVybiBleHBvcnRNYXBcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZShwYXRoLCBjb250ZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIG0gPSBuZXcgRXhwb3J0TWFwKHBhdGgpXG5cbiAgICB0cnkge1xuICAgICAgdmFyIGFzdCA9IHBhcnNlKGNvbnRlbnQsIGNvbnRleHQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBtLmVycm9ycy5wdXNoKGVycilcbiAgICAgIHJldHVybiBtIC8vIGNhbid0IGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gYXR0ZW1wdCB0byBjb2xsZWN0IG1vZHVsZSBkb2NcbiAgICBhc3QuY29tbWVudHMuc29tZShjID0+IHtcbiAgICAgIGlmIChjLnR5cGUgIT09ICdCbG9jaycpIHJldHVybiBmYWxzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jID0gZG9jdHJpbmUucGFyc2UoYy52YWx1ZSwgeyB1bndyYXA6IHRydWUgfSlcbiAgICAgICAgaWYgKGRvYy50YWdzLnNvbWUodCA9PiB0LnRpdGxlID09PSAnbW9kdWxlJykpIHtcbiAgICAgICAgICBtLmRvYyA9IGRvY1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSlcblxuICAgIGNvbnN0IG5hbWVzcGFjZXMgPSBuZXcgTWFwKClcblxuICAgIGZ1bmN0aW9uIHJlbW90ZVBhdGgobm9kZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUucmVsYXRpdmUobm9kZS5zb3VyY2UudmFsdWUsIHBhdGgsIGNvbnRleHQuc2V0dGluZ3MpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUltcG9ydChub2RlKSB7XG4gICAgICBjb25zdCBycCA9IHJlbW90ZVBhdGgobm9kZSlcbiAgICAgIGlmIChycCA9PSBudWxsKSByZXR1cm4gbnVsbFxuICAgICAgcmV0dXJuIEV4cG9ydE1hcC5mb3IocnAsIGNvbnRleHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TmFtZXNwYWNlKGlkZW50aWZpZXIpIHtcbiAgICAgIGlmICghbmFtZXNwYWNlcy5oYXMoaWRlbnRpZmllci5uYW1lKSkgcmV0dXJuXG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlSW1wb3J0KG5hbWVzcGFjZXMuZ2V0KGlkZW50aWZpZXIubmFtZSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTmFtZXNwYWNlKG9iamVjdCwgaWRlbnRpZmllcikge1xuICAgICAgY29uc3QgbnNmbiA9IGdldE5hbWVzcGFjZShpZGVudGlmaWVyKVxuICAgICAgaWYgKG5zZm4pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ25hbWVzcGFjZScsIHsgZ2V0OiBuc2ZuIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3RcbiAgICB9XG5cblxuICAgIGFzdC5ib2R5LmZvckVhY2goZnVuY3Rpb24gKG4pIHtcblxuICAgICAgaWYgKG4udHlwZSA9PT0gJ0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbicpIHtcbiAgICAgICAgY29uc3QgZXhwb3J0TWV0YSA9IGNhcHR1cmVEb2MobilcbiAgICAgICAgaWYgKG4uZGVjbGFyYXRpb24udHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgYWRkTmFtZXNwYWNlKGV4cG9ydE1ldGEsIG4uZGVjbGFyYXRpb24pXG4gICAgICAgIH1cbiAgICAgICAgbS5uYW1lc3BhY2Uuc2V0KCdkZWZhdWx0JywgZXhwb3J0TWV0YSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChuLnR5cGUgPT09ICdFeHBvcnRBbGxEZWNsYXJhdGlvbicpIHtcbiAgICAgICAgbGV0IHJlbW90ZU1hcCA9IHJlbW90ZVBhdGgobilcbiAgICAgICAgaWYgKHJlbW90ZU1hcCA9PSBudWxsKSByZXR1cm5cbiAgICAgICAgbS5kZXBlbmRlbmNpZXMuc2V0KHJlbW90ZU1hcCwgKCkgPT4gRXhwb3J0TWFwLmZvcihyZW1vdGVNYXAsIGNvbnRleHQpKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gY2FwdHVyZSBuYW1lc3BhY2VzIGluIGNhc2Ugb2YgbGF0ZXIgZXhwb3J0XG4gICAgICBpZiAobi50eXBlID09PSAnSW1wb3J0RGVjbGFyYXRpb24nKSB7XG4gICAgICAgIGxldCBuc1xuICAgICAgICBpZiAobi5zcGVjaWZpZXJzLnNvbWUocyA9PiBzLnR5cGUgPT09ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInICYmIChucyA9IHMpKSkge1xuICAgICAgICAgIG5hbWVzcGFjZXMuc2V0KG5zLmxvY2FsLm5hbWUsIG4pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChuLnR5cGUgPT09ICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJyl7XG4gICAgICAgIC8vIGNhcHR1cmUgZGVjbGFyYXRpb25cbiAgICAgICAgaWYgKG4uZGVjbGFyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAobi5kZWNsYXJhdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0NsYXNzRGVjbGFyYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnVHlwZUFsaWFzJzogLy8gZmxvd3R5cGUgd2l0aCBiYWJlbC1lc2xpbnQgcGFyc2VyXG4gICAgICAgICAgICAgIG0ubmFtZXNwYWNlLnNldChuLmRlY2xhcmF0aW9uLmlkLm5hbWUsIGNhcHR1cmVEb2MobikpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICAgICAgbi5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMuZm9yRWFjaCgoZCkgPT5cbiAgICAgICAgICAgICAgICByZWN1cnNpdmVQYXR0ZXJuQ2FwdHVyZShkLmlkLCBpZCA9PiBtLm5hbWVzcGFjZS5zZXQoaWQubmFtZSwgY2FwdHVyZURvYyhkLCBuKSkpKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG4uc3BlY2lmaWVycy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhwb3J0TWV0YSA9IHt9XG4gICAgICAgICAgbGV0IGxvY2FsXG5cbiAgICAgICAgICBzd2l0Y2ggKHMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnRXhwb3J0RGVmYXVsdFNwZWNpZmllcic6XG4gICAgICAgICAgICAgIGlmICghbi5zb3VyY2UpIHJldHVyblxuICAgICAgICAgICAgICBsb2NhbCA9ICdkZWZhdWx0J1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyJzpcbiAgICAgICAgICAgICAgbS5uYW1lc3BhY2Uuc2V0KHMuZXhwb3J0ZWQubmFtZSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydE1ldGEsICduYW1lc3BhY2UnLCB7XG4gICAgICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gcmVzb2x2ZUltcG9ydChuKSB9LFxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBjYXNlICdFeHBvcnRTcGVjaWZpZXInOlxuICAgICAgICAgICAgICBpZiAoIW4uc291cmNlKSB7XG4gICAgICAgICAgICAgICAgbS5uYW1lc3BhY2Uuc2V0KHMuZXhwb3J0ZWQubmFtZSwgYWRkTmFtZXNwYWNlKGV4cG9ydE1ldGEsIHMubG9jYWwpKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGVsc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbG9jYWwgPSBzLmxvY2FsLm5hbWVcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0b2RvOiBKU0RvY1xuICAgICAgICAgIG0ucmVleHBvcnRzLnNldChzLmV4cG9ydGVkLm5hbWUsIHsgbG9jYWwsIGdldEltcG9ydDogKCkgPT4gcmVzb2x2ZUltcG9ydChuKSB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gbVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGNoZWNrIGV4cGxpY2l0bHkgcmUtZXhwb3J0ZWQgbmFtZXMgZm9yIGV4aXN0ZW5jZVxuICAgKiBpbiB0aGUgYmFzZSBuYW1lc3BhY2UsIGJ1dCBpdCB3aWxsIGV4cGFuZCBhbGwgYGV4cG9ydCAqIGZyb20gJy4uLidgIGV4cG9ydHNcbiAgICogaWYgbm90IGZvdW5kIGluIHRoZSBleHBsaWNpdCBuYW1lc3BhY2UuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgbmFtZWAgaXMgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuXG4gICAqL1xuICBoYXMobmFtZSkge1xuICAgIGlmICh0aGlzLm5hbWVzcGFjZS5oYXMobmFtZSkpIHJldHVybiB0cnVlXG4gICAgaWYgKHRoaXMucmVleHBvcnRzLmhhcyhuYW1lKSkgcmV0dXJuIHRydWVcblxuICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcy52YWx1ZXMoKSkge1xuICAgICAgbGV0IGlubmVyTWFwID0gZGVwKClcblxuICAgICAgLy8gdG9kbzogcmVwb3J0IGFzIHVucmVzb2x2ZWQ/XG4gICAgICBpZiAoIWlubmVyTWFwKSBjb250aW51ZVxuXG4gICAgICBpZiAoaW5uZXJNYXAuaGFzKG5hbWUpKSByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZ2V0KG5hbWUpIHtcbiAgICBpZiAodGhpcy5uYW1lc3BhY2UuaGFzKG5hbWUpKSByZXR1cm4gdGhpcy5uYW1lc3BhY2UuZ2V0KG5hbWUpXG5cbiAgICBpZiAodGhpcy5yZWV4cG9ydHMuaGFzKG5hbWUpKSB7XG4gICAgICBjb25zdCB7IGxvY2FsLCBnZXRJbXBvcnQgfSA9IHRoaXMucmVleHBvcnRzLmdldChuYW1lKVxuICAgICAgICAgICwgaW1wb3J0ZWQgPSBnZXRJbXBvcnQoKVxuICAgICAgaWYgKGltcG9ydGVkID09IG51bGwpIHJldHVybiB1bmRlZmluZWRcblxuICAgICAgLy8gc2FmZWd1YXJkIGFnYWluc3QgY3ljbGVzLCBvbmx5IGlmIG5hbWUgbWF0Y2hlc1xuICAgICAgaWYgKGltcG9ydGVkLnBhdGggPT09IHRoaXMucGF0aCAmJiBsb2NhbCA9PT0gbmFtZSkgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgICByZXR1cm4gaW1wb3J0ZWQuZ2V0KGxvY2FsKVxuICAgIH1cblxuICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcy52YWx1ZXMoKSkge1xuICAgICAgbGV0IGlubmVyTWFwID0gZGVwKClcbiAgICAgIC8vIHRvZG86IHJlcG9ydCBhcyB1bnJlc29sdmVkP1xuICAgICAgaWYgKCFpbm5lck1hcCkgY29udGludWVcblxuICAgICAgLy8gc2FmZWd1YXJkIGFnYWluc3QgY3ljbGVzXG4gICAgICBpZiAoaW5uZXJNYXAucGF0aCA9PT0gdGhpcy5wYXRoKSBjb250aW51ZVxuXG4gICAgICBsZXQgaW5uZXJWYWx1ZSA9IGlubmVyTWFwLmdldChuYW1lKVxuICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGlubmVyVmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdGhpcy5uYW1lc3BhY2UuZm9yRWFjaCgodiwgbikgPT5cbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdiwgbiwgdGhpcykpXG5cbiAgICB0aGlzLnJlZXhwb3J0cy5mb3JFYWNoKCh7IGdldEltcG9ydCwgbG9jYWwgfSwgbmFtZSkgPT5cbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZ2V0SW1wb3J0KCkuZ2V0KGxvY2FsKSwgbmFtZSwgdGhpcykpXG5cbiAgICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGRlcCA9PiBkZXAoKS5mb3JFYWNoKCh2LCBuKSA9PlxuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2LCBuLCB0aGlzKSkpXG4gIH1cblxuICAvLyB0b2RvOiBrZXlzLCB2YWx1ZXMsIGVudHJpZXM/XG5cbiAgcmVwb3J0RXJyb3JzKGNvbnRleHQsIGRlY2xhcmF0aW9uKSB7XG4gICAgY29udGV4dC5yZXBvcnQoe1xuICAgICAgbm9kZTogZGVjbGFyYXRpb24uc291cmNlLFxuICAgICAgbWVzc2FnZTogYFBhcnNlIGVycm9ycyBpbiBpbXBvcnRlZCBtb2R1bGUgJyR7ZGVjbGFyYXRpb24uc291cmNlLnZhbHVlfSc6IGAgK1xuICAgICAgICAgICAgICAgICAgYCR7dGhpcy5lcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZSA9PiBgJHtlLm1lc3NhZ2V9ICgke2UubGluZU51bWJlcn06JHtlLmNvbHVtbn0pYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfWAsXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIEpTRG9jIGZyb20gdGhlIGZpcnN0IG5vZGUgdGhhdCBoYXMgbGVhZGluZyBjb21tZW50c1xuICogQHBhcmFtICB7Li4uW3R5cGVdfSBub2RlcyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHt7ZG9jOiBvYmplY3R9fVxuICovXG5mdW5jdGlvbiBjYXB0dXJlRG9jKC4uLm5vZGVzKSB7XG4gIGNvbnN0IG1ldGFkYXRhID0ge31cblxuICAvLyAnc29tZScgc2hvcnQtY2lyY3VpdHMgb24gZmlyc3QgJ3RydWUnXG4gIG5vZGVzLnNvbWUobiA9PiB7XG4gICAgaWYgKCFuLmxlYWRpbmdDb21tZW50cykgcmV0dXJuIGZhbHNlXG5cbiAgICAvLyBjYXB0dXJlIFhTRG9jXG4gICAgbi5sZWFkaW5nQ29tbWVudHMuZm9yRWFjaChjb21tZW50ID0+IHtcbiAgICAgIC8vIHNraXAgbm9uLWJsb2NrIGNvbW1lbnRzXG4gICAgICBpZiAoY29tbWVudC52YWx1ZS5zbGljZSgwLCA0KSAhPT0gXCIqXFxuICpcIikgcmV0dXJuXG4gICAgICB0cnkge1xuICAgICAgICBtZXRhZGF0YS5kb2MgPSBkb2N0cmluZS5wYXJzZShjb21tZW50LnZhbHVlLCB7IHVud3JhcDogdHJ1ZSB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8qIGRvbid0IGNhcmUsIGZvciBub3c/IG1heWJlIGFkZCB0byBgZXJyb3JzP2AgKi9cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH0pXG5cbiAgcmV0dXJuIG1ldGFkYXRhXG59XG5cbi8qKlxuICogVHJhdmVyc2UgYSBwYXR0ZXJuL2lkZW50aWZpZXIgbm9kZSwgY2FsbGluZyAnY2FsbGJhY2snXG4gKiBmb3IgZWFjaCBsZWFmIGlkZW50aWZpZXIuXG4gKiBAcGFyYW0gIHtub2RlfSAgIHBhdHRlcm5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY3Vyc2l2ZVBhdHRlcm5DYXB0dXJlKHBhdHRlcm4sIGNhbGxiYWNrKSB7XG4gIHN3aXRjaCAocGF0dGVybi50eXBlKSB7XG4gICAgY2FzZSAnSWRlbnRpZmllcic6IC8vIGJhc2UgY2FzZVxuICAgICAgY2FsbGJhY2socGF0dGVybilcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdPYmplY3RQYXR0ZXJuJzpcbiAgICAgIHBhdHRlcm4ucHJvcGVydGllcy5mb3JFYWNoKCh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgcmVjdXJzaXZlUGF0dGVybkNhcHR1cmUodmFsdWUsIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdBcnJheVBhdHRlcm4nOlxuICAgICAgcGF0dGVybi5lbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHJldHVyblxuICAgICAgICByZWN1cnNpdmVQYXR0ZXJuQ2FwdHVyZShlbGVtZW50LCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgICBicmVha1xuICB9XG59XG4iXX0=